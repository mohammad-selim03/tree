{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/database/src/index.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\nexport * from '@prisma/client';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n    globalForPrisma.prisma ||\r\n    new PrismaClient({\r\n        log: ['query', 'error', 'warn'],\r\n    });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;;AAIA,MAAM;AAEC,MAAM,SACT,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACb,KAAK;QAAC;QAAS;QAAS;KAAO;AACnC;AAEJ,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/value-objects/Email.ts"],"sourcesContent":["import { z } from 'zod';\r\n\r\nexport class Email {\r\n    private readonly value: string;\r\n\r\n    private constructor(value: string) {\r\n        this.value = value;\r\n    }\r\n\r\n    public static create(email: string): Email {\r\n        const schema = z.string().email();\r\n        const result = schema.safeParse(email);\r\n\r\n        if (!result.success) {\r\n            throw new Error('Invalid email format');\r\n        }\r\n\r\n        return new Email(email);\r\n    }\r\n\r\n    public getValue(): string {\r\n        return this.value;\r\n    }\r\n\r\n    public equals(other: Email): boolean {\r\n        return this.value === other.value;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM;IACQ,MAAc;IAE/B,YAAoB,KAAa,CAAE;QAC/B,IAAI,CAAC,KAAK,GAAG;IACjB;IAEA,OAAc,OAAO,KAAa,EAAS;QACvC,MAAM,SAAS,2NAAC,CAAC,MAAM,GAAG,KAAK;QAC/B,MAAM,SAAS,OAAO,SAAS,CAAC;QAEhC,IAAI,CAAC,OAAO,OAAO,EAAE;YACjB,MAAM,IAAI,MAAM;QACpB;QAEA,OAAO,IAAI,MAAM;IACrB;IAEO,WAAmB;QACtB,OAAO,IAAI,CAAC,KAAK;IACrB;IAEO,OAAO,KAAY,EAAW;QACjC,OAAO,IAAI,CAAC,KAAK,KAAK,MAAM,KAAK;IACrC;AACJ"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/value-objects/Password.ts"],"sourcesContent":["/**\r\n * Password Value Object\r\n * \r\n * Encapsulates password validation and hashing logic.\r\n * Ensures passwords meet security requirements.\r\n */\r\n\r\nimport bcrypt from 'bcryptjs';\r\n\r\nexport class Password {\r\n  private readonly hashedValue: string;\r\n  private static readonly SALT_ROUNDS = 12;\r\n  private static readonly MIN_LENGTH = 8;\r\n\r\n  private constructor(hashedValue: string) {\r\n    this.hashedValue = hashedValue;\r\n  }\r\n\r\n  /**\r\n   * Create a Password from plaintext (for registration/password change)\r\n   */\r\n  public static async create(plaintext: string): Promise<Password> {\r\n    Password.validate(plaintext);\r\n    const hashed = await bcrypt.hash(plaintext, Password.SALT_ROUNDS);\r\n    return new Password(hashed);\r\n  }\r\n\r\n  /**\r\n   * Reconstitute a Password from a hash (from database)\r\n   */\r\n  public static fromHash(hash: string): Password {\r\n    if (!hash || hash.length === 0) {\r\n      throw new Error('Password hash cannot be empty');\r\n    }\r\n    return new Password(hash);\r\n  }\r\n\r\n  /**\r\n   * Validate plaintext password meets requirements\r\n   */\r\n  private static validate(plaintext: string): void {\r\n    if (!plaintext || plaintext.length === 0) {\r\n      throw new Error('Password cannot be empty');\r\n    }\r\n\r\n    if (plaintext.length < Password.MIN_LENGTH) {\r\n      throw new Error(`Password must be at least ${Password.MIN_LENGTH} characters`);\r\n    }\r\n\r\n    if (plaintext.length > 128) {\r\n      throw new Error('Password cannot exceed 128 characters');\r\n    }\r\n\r\n    // Must contain at least one uppercase letter\r\n    if (!/[A-Z]/.test(plaintext)) {\r\n      throw new Error('Password must contain at least one uppercase letter');\r\n    }\r\n\r\n    // Must contain at least one lowercase letter\r\n    if (!/[a-z]/.test(plaintext)) {\r\n      throw new Error('Password must contain at least one lowercase letter');\r\n    }\r\n\r\n    // Must contain at least one number\r\n    if (!/[0-9]/.test(plaintext)) {\r\n      throw new Error('Password must contain at least one number');\r\n    }\r\n\r\n    // Check for common weak passwords\r\n    const weakPasswords = ['Password123', 'Admin123', 'Welcome123'];\r\n    if (weakPasswords.includes(plaintext)) {\r\n      throw new Error('Password is too common, please choose a stronger password');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compare plaintext password with hashed password\r\n   */\r\n  public async compare(plaintext: string): Promise<boolean> {\r\n    return bcrypt.compare(plaintext, this.hashedValue);\r\n  }\r\n\r\n  /**\r\n   * Get the hashed value (for persistence)\r\n   */\r\n  public getHashedValue(): string {\r\n    return this.hashedValue;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;;AAEO,MAAM;IACM,YAAoB;IACrC,OAAwB,cAAc,GAAG;IACzC,OAAwB,aAAa,EAAE;IAEvC,YAAoB,WAAmB,CAAE;QACvC,IAAI,CAAC,WAAW,GAAG;IACrB;IAEA;;GAEC,GACD,aAAoB,OAAO,SAAiB,EAAqB;QAC/D,SAAS,QAAQ,CAAC;QAClB,MAAM,SAAS,MAAM,mMAAM,CAAC,IAAI,CAAC,WAAW,SAAS,WAAW;QAChE,OAAO,IAAI,SAAS;IACtB;IAEA;;GAEC,GACD,OAAc,SAAS,IAAY,EAAY;QAC7C,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;YAC9B,MAAM,IAAI,MAAM;QAClB;QACA,OAAO,IAAI,SAAS;IACtB;IAEA;;GAEC,GACD,OAAe,SAAS,SAAiB,EAAQ;QAC/C,IAAI,CAAC,aAAa,UAAU,MAAM,KAAK,GAAG;YACxC,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI,UAAU,MAAM,GAAG,SAAS,UAAU,EAAE;YAC1C,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,SAAS,UAAU,CAAC,WAAW,CAAC;QAC/E;QAEA,IAAI,UAAU,MAAM,GAAG,KAAK;YAC1B,MAAM,IAAI,MAAM;QAClB;QAEA,6CAA6C;QAC7C,IAAI,CAAC,QAAQ,IAAI,CAAC,YAAY;YAC5B,MAAM,IAAI,MAAM;QAClB;QAEA,6CAA6C;QAC7C,IAAI,CAAC,QAAQ,IAAI,CAAC,YAAY;YAC5B,MAAM,IAAI,MAAM;QAClB;QAEA,mCAAmC;QACnC,IAAI,CAAC,QAAQ,IAAI,CAAC,YAAY;YAC5B,MAAM,IAAI,MAAM;QAClB;QAEA,kCAAkC;QAClC,MAAM,gBAAgB;YAAC;YAAe;YAAY;SAAa;QAC/D,IAAI,cAAc,QAAQ,CAAC,YAAY;YACrC,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;GAEC,GACD,MAAa,QAAQ,SAAiB,EAAoB;QACxD,OAAO,mMAAM,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,WAAW;IACnD;IAEA;;GAEC,GACD,AAAO,iBAAyB;QAC9B,OAAO,IAAI,CAAC,WAAW;IACzB;AACF"}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/application/use-cases/LoginUserUseCase.ts"],"sourcesContent":["/**\r\n * Login User Use Case\r\n * \r\n * Handles user authentication with email/password.\r\n * Verifies credentials and returns authentication tokens.\r\n */\r\n\r\nimport { IUserRepository } from '../../domain/repositories/IUserRepository';\r\nimport { Email } from '../../domain/value-objects/Email';\r\nimport { Password } from '../../domain/value-objects/Password';\r\nimport { TokenService } from '../../domain/services/TokenService';\r\nimport { LoginUserDTO, AuthResponseDTO } from '../dtos/AuthDTO';\r\n\r\nexport class LoginUserUseCase {\r\n  constructor(\r\n    private userRepository: IUserRepository,\r\n    private tokenService: TokenService\r\n  ) {}\r\n\r\n  async execute(dto: LoginUserDTO): Promise<AuthResponseDTO> {\r\n    // 1. Validate and create email value object\r\n    const email = Email.create(dto.email);\r\n\r\n    // 2. Find user by email\r\n    const user = await this.userRepository.findByEmail(email);\r\n    if (!user) {\r\n      throw new Error('Invalid email or password');\r\n    }\r\n\r\n    // 3. Verify password\r\n    const userProps = user.getProps();\r\n    const password = Password.fromHash(userProps.passwordHash);\r\n    const isValidPassword = await password.compare(dto.password);\r\n\r\n    if (!isValidPassword) {\r\n      throw new Error('Invalid email or password');\r\n    }\r\n\r\n    // 4. Generate authentication tokens\r\n    const tokens = this.tokenService.generateTokenPair(\r\n      user.id,\r\n      user.email.getValue(),\r\n      user.role\r\n    );\r\n\r\n    // 5. Return response\r\n    return {\r\n      user: {\r\n        id: user.id,\r\n        email: user.email.getValue(),\r\n        role: user.role,\r\n        createdAt: user.createdAt.toISOString(),\r\n      },\r\n      tokens: {\r\n        accessToken: tokens.accessToken,\r\n        refreshToken: tokens.refreshToken,\r\n        expiresIn: 900, // 15 minutes in seconds\r\n      },\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAGD;AACA;;;AAIO,MAAM;;;IACX,YACE,AAAQ,cAA+B,EACvC,AAAQ,YAA0B,CAClC;aAFQ,iBAAA;aACA,eAAA;IACP;IAEH,MAAM,QAAQ,GAAiB,EAA4B;QACzD,4CAA4C;QAC5C,MAAM,QAAQ,qLAAK,CAAC,MAAM,CAAC,IAAI,KAAK;QAEpC,wBAAwB;QACxB,MAAM,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC;QACnD,IAAI,CAAC,MAAM;YACT,MAAM,IAAI,MAAM;QAClB;QAEA,qBAAqB;QACrB,MAAM,YAAY,KAAK,QAAQ;QAC/B,MAAM,WAAW,2LAAQ,CAAC,QAAQ,CAAC,UAAU,YAAY;QACzD,MAAM,kBAAkB,MAAM,SAAS,OAAO,CAAC,IAAI,QAAQ;QAE3D,IAAI,CAAC,iBAAiB;YACpB,MAAM,IAAI,MAAM;QAClB;QAEA,oCAAoC;QACpC,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAChD,KAAK,EAAE,EACP,KAAK,KAAK,CAAC,QAAQ,IACnB,KAAK,IAAI;QAGX,qBAAqB;QACrB,OAAO;YACL,MAAM;gBACJ,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK,CAAC,QAAQ;gBAC1B,MAAM,KAAK,IAAI;gBACf,WAAW,KAAK,SAAS,CAAC,WAAW;YACvC;YACA,QAAQ;gBACN,aAAa,OAAO,WAAW;gBAC/B,cAAc,OAAO,YAAY;gBACjC,WAAW;YACb;QACF;IACF;AACF"}},
    {"offset": {"line": 247, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/entities/User.ts"],"sourcesContent":["import { Email } from '../value-objects/Email';\r\n\r\nexport enum UserRole {\r\n    BUYER = 'BUYER',\r\n    SELLER = 'SELLER',\r\n    ADMIN = 'ADMIN'\r\n}\r\n\r\nexport interface UserProps {\r\n    id: string;\r\n    email: Email;\r\n    passwordHash: string;\r\n    role: UserRole;\r\n    createdAt: Date;\r\n    updatedAt: Date;\r\n}\r\n\r\nexport class User {\r\n    private props: UserProps;\r\n\r\n    private constructor(props: UserProps) {\r\n        this.props = props;\r\n    }\r\n\r\n    public static create(props: UserProps): User {\r\n        return new User(props);\r\n    }\r\n\r\n    /**\r\n     * Reconstitute a User from persistence (database)\r\n     */\r\n    public static reconstitute(props: UserProps): User {\r\n        return new User(props);\r\n    }\r\n\r\n    get id(): string {\r\n        return this.props.id;\r\n    }\r\n\r\n    get email(): Email {\r\n        return this.props.email;\r\n    }\r\n\r\n    get role(): UserRole {\r\n        return this.props.role;\r\n    }\r\n\r\n    get createdAt(): Date {\r\n        return this.props.createdAt;\r\n    }\r\n\r\n    get updatedAt(): Date {\r\n        return this.props.updatedAt;\r\n    }\r\n\r\n    public isAdmin(): boolean {\r\n        return this.props.role === UserRole.ADMIN;\r\n    }\r\n\r\n    public isSeller(): boolean {\r\n        return this.props.role === UserRole.SELLER;\r\n    }\r\n\r\n    public isBuyer(): boolean {\r\n        return this.props.role === UserRole.BUYER;\r\n    }\r\n\r\n    /**\r\n     * Allow accessing props for persistence (used by repositories)\r\n     */\r\n    public getProps(): UserProps {\r\n        return { ...this.props };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAEO,IAAA,AAAK,kCAAA;;;;WAAA;;AAeL,MAAM;IACD,MAAiB;IAEzB,YAAoB,KAAgB,CAAE;QAClC,IAAI,CAAC,KAAK,GAAG;IACjB;IAEA,OAAc,OAAO,KAAgB,EAAQ;QACzC,OAAO,IAAI,KAAK;IACpB;IAEA;;KAEC,GACD,OAAc,aAAa,KAAgB,EAAQ;QAC/C,OAAO,IAAI,KAAK;IACpB;IAEA,IAAI,KAAa;QACb,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;IACxB;IAEA,IAAI,QAAe;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK;IAC3B;IAEA,IAAI,OAAiB;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI;IAC1B;IAEA,IAAI,YAAkB;QAClB,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS;IAC/B;IAEA,IAAI,YAAkB;QAClB,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS;IAC/B;IAEO,UAAmB;QACtB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI;IAC1B;IAEO,WAAoB;QACvB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI;IAC1B;IAEO,UAAmB;QACtB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI;IAC1B;IAEA;;KAEC,GACD,AAAO,WAAsB;QACzB,OAAO;YAAE,GAAG,IAAI,CAAC,KAAK;QAAC;IAC3B;AACJ"}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/infrastructure/repositories/PrismaUserRepository.ts"],"sourcesContent":["/**\r\n * Prisma User Repository Implementation\r\n * \r\n * Implements IUserRepository using Prisma ORM.\r\n */\r\n\r\nimport { PrismaClient } from '@repo/database';\r\nimport { IUserRepository } from '../../domain/repositories/IUserRepository';\r\nimport { User, UserRole } from '../../domain/entities/User';\r\nimport { Email } from '../../domain/value-objects/Email';\r\n\r\nexport class PrismaUserRepository implements IUserRepository {\r\n  constructor(private prisma: PrismaClient) {}\r\n\r\n  async findById(id: string): Promise<User | null> {\r\n    const data = await this.prisma.user.findUnique({\r\n      where: { id, deletedAt: null },\r\n    });\r\n\r\n    if (!data) return null;\r\n\r\n    return this.toDomain(data);\r\n  }\r\n\r\n  async findByEmail(email: Email): Promise<User | null> {\r\n    const data = await this.prisma.user.findUnique({\r\n      where: { email: email.getValue(), deletedAt: null },\r\n    });\r\n\r\n    if (!data) return null;\r\n\r\n    return this.toDomain(data);\r\n  }\r\n\r\n  async save(user: User): Promise<void> {\r\n    const data = this.toPersistence(user);\r\n\r\n    await this.prisma.user.upsert({\r\n      where: { id: user.id },\r\n      create: data,\r\n      update: {\r\n        email: data.email,\r\n        passwordHash: data.passwordHash,\r\n        role: data.role,\r\n        profile: data.profile,\r\n        updatedAt: data.updatedAt,\r\n      },\r\n    });\r\n  }\r\n\r\n  async delete(id: string): Promise<void> {\r\n    await this.prisma.user.update({\r\n      where: { id },\r\n      data: { deletedAt: new Date() },\r\n    });\r\n  }\r\n\r\n  async existsByEmail(email: Email): Promise<boolean> {\r\n    const count = await this.prisma.user.count({\r\n      where: {\r\n        email: email.getValue(),\r\n        deletedAt: null,\r\n      },\r\n    });\r\n\r\n    return count > 0;\r\n  }\r\n\r\n  async findByRole(role: string): Promise<User[]> {\r\n    const data = await this.prisma.user.findMany({\r\n      where: {\r\n        role: role,\r\n        deletedAt: null,\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return data.map((d: any) => this.toDomain(d));\r\n  }\r\n\r\n  async count(): Promise<number> {\r\n    return this.prisma.user.count({\r\n      where: { deletedAt: null },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Convert Prisma model to Domain entity\r\n   */\r\n  private toDomain(data: any): User {\r\n    return User.reconstitute({\r\n      id: data.id,\r\n      email: Email.create(data.email),\r\n      passwordHash: data.passwordHash,\r\n      role: data.role as UserRole,\r\n      createdAt: data.createdAt,\r\n      updatedAt: data.updatedAt,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Convert Domain entity to Prisma model data\r\n   */\r\n  private toPersistence(user: User): any {\r\n    const props = user.getProps();\r\n    \r\n    return {\r\n      id: user.id,\r\n      email: user.email.getValue(),\r\n      passwordHash: props.passwordHash,\r\n      role: user.role,\r\n      profile: null,\r\n      createdAt: user.createdAt,\r\n      updatedAt: user.updatedAt,\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAID;AACA;;;AAEO,MAAM;;IACX,YAAY,AAAQ,MAAoB,CAAE;aAAtB,SAAA;IAAuB;IAE3C,MAAM,SAAS,EAAU,EAAwB;QAC/C,MAAM,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAC7C,OAAO;gBAAE;gBAAI,WAAW;YAAK;QAC/B;QAEA,IAAI,CAAC,MAAM,OAAO;QAElB,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB;IAEA,MAAM,YAAY,KAAY,EAAwB;QACpD,MAAM,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAC7C,OAAO;gBAAE,OAAO,MAAM,QAAQ;gBAAI,WAAW;YAAK;QACpD;QAEA,IAAI,CAAC,MAAM,OAAO;QAElB,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB;IAEA,MAAM,KAAK,IAAU,EAAiB;QACpC,MAAM,OAAO,IAAI,CAAC,aAAa,CAAC;QAEhC,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAC5B,OAAO;gBAAE,IAAI,KAAK,EAAE;YAAC;YACrB,QAAQ;YACR,QAAQ;gBACN,OAAO,KAAK,KAAK;gBACjB,cAAc,KAAK,YAAY;gBAC/B,MAAM,KAAK,IAAI;gBACf,SAAS,KAAK,OAAO;gBACrB,WAAW,KAAK,SAAS;YAC3B;QACF;IACF;IAEA,MAAM,OAAO,EAAU,EAAiB;QACtC,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAC5B,OAAO;gBAAE;YAAG;YACZ,MAAM;gBAAE,WAAW,IAAI;YAAO;QAChC;IACF;IAEA,MAAM,cAAc,KAAY,EAAoB;QAClD,MAAM,QAAQ,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;YACzC,OAAO;gBACL,OAAO,MAAM,QAAQ;gBACrB,WAAW;YACb;QACF;QAEA,OAAO,QAAQ;IACjB;IAEA,MAAM,WAAW,IAAY,EAAmB;QAC9C,MAAM,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YAC3C,OAAO;gBACL,MAAM;gBACN,WAAW;YACb;YACA,SAAS;gBAAE,WAAW;YAAO;QAC/B;QAEA,OAAO,KAAK,GAAG,CAAC,CAAC,IAAW,IAAI,CAAC,QAAQ,CAAC;IAC5C;IAEA,MAAM,QAAyB;QAC7B,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;YAC5B,OAAO;gBAAE,WAAW;YAAK;QAC3B;IACF;IAEA;;GAEC,GACD,AAAQ,SAAS,IAAS,EAAQ;QAChC,OAAO,2KAAI,CAAC,YAAY,CAAC;YACvB,IAAI,KAAK,EAAE;YACX,OAAO,qLAAK,CAAC,MAAM,CAAC,KAAK,KAAK;YAC9B,cAAc,KAAK,YAAY;YAC/B,MAAM,KAAK,IAAI;YACf,WAAW,KAAK,SAAS;YACzB,WAAW,KAAK,SAAS;QAC3B;IACF;IAEA;;GAEC,GACD,AAAQ,cAAc,IAAU,EAAO;QACrC,MAAM,QAAQ,KAAK,QAAQ;QAE3B,OAAO;YACL,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK,CAAC,QAAQ;YAC1B,cAAc,MAAM,YAAY;YAChC,MAAM,KAAK,IAAI;YACf,SAAS;YACT,WAAW,KAAK,SAAS;YACzB,WAAW,KAAK,SAAS;QAC3B;IACF;AACF"}},
    {"offset": {"line": 448, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/value-objects/AccessToken.ts"],"sourcesContent":["/**\r\n * AccessToken Value Object\r\n * \r\n * Encapsulates JWT access token logic.\r\n * Short-lived token for API authentication (15 minutes).\r\n */\r\n\r\nimport jwt from 'jsonwebtoken';\r\n\r\nexport interface AccessTokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n}\r\n\r\nexport class AccessToken {\r\n  private readonly token: string;\r\n  private static readonly EXPIRY = '15m'; // 15 minutes\r\n  private static readonly SECRET = process.env.JWT_ACCESS_SECRET || 'default-access-secret-change-in-production';\r\n\r\n  private constructor(token: string) {\r\n    this.token = token;\r\n  }\r\n\r\n  /**\r\n   * Generate a new access token\r\n   */\r\n  public static generate(payload: AccessTokenPayload): AccessToken {\r\n    const token = jwt.sign(\r\n      payload,\r\n      AccessToken.SECRET,\r\n      {\r\n        expiresIn: AccessToken.EXPIRY,\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }\r\n    );\r\n\r\n    return new AccessToken(token);\r\n  }\r\n\r\n  /**\r\n   * Verify and decode an access token\r\n   */\r\n  public static verify(token: string): AccessTokenPayload {\r\n    try {\r\n      const decoded = jwt.verify(token, AccessToken.SECRET, {\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }) as AccessTokenPayload;\r\n\r\n      return decoded;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        throw new Error('Access token has expired');\r\n      }\r\n      if (error instanceof jwt.JsonWebTokenError) {\r\n        throw new Error('Invalid access token');\r\n      }\r\n      throw new Error('Access token verification failed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create from existing token string (for verification)\r\n   */\r\n  public static fromString(token: string): AccessToken {\r\n    // Verify the token is valid before creating the value object\r\n    AccessToken.verify(token);\r\n    return new AccessToken(token);\r\n  }\r\n\r\n  /**\r\n   * Get the token string\r\n   */\r\n  public getValue(): string {\r\n    return this.token;\r\n  }\r\n\r\n  /**\r\n   * Check if token is expired\r\n   */\r\n  public isExpired(): boolean {\r\n    try {\r\n      jwt.verify(this.token, AccessToken.SECRET);\r\n      return false;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;;AAQO,MAAM;IACM,MAAc;IAC/B,OAAwB,SAAS,MAAM;IACvC,OAAwB,SAAS,QAAQ,GAAG,CAAC,iBAAiB,IAAI,6CAA6C;IAE/G,YAAoB,KAAa,CAAE;QACjC,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;GAEC,GACD,OAAc,SAAS,OAA2B,EAAe;QAC/D,MAAM,QAAQ,2MAAG,CAAC,IAAI,CACpB,SACA,YAAY,MAAM,EAClB;YACE,WAAW,YAAY,MAAM;YAC7B,QAAQ;YACR,UAAU;QACZ;QAGF,OAAO,IAAI,YAAY;IACzB;IAEA;;GAEC,GACD,OAAc,OAAO,KAAa,EAAsB;QACtD,IAAI;YACF,MAAM,UAAU,2MAAG,CAAC,MAAM,CAAC,OAAO,YAAY,MAAM,EAAE;gBACpD,QAAQ;gBACR,UAAU;YACZ;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;GAEC,GACD,OAAc,WAAW,KAAa,EAAe;QACnD,6DAA6D;QAC7D,YAAY,MAAM,CAAC;QACnB,OAAO,IAAI,YAAY;IACzB;IAEA;;GAEC,GACD,AAAO,WAAmB;QACxB,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA;;GAEC,GACD,AAAO,YAAqB;QAC1B,IAAI;YACF,2MAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,YAAY,MAAM;YACzC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,OAAO;YACT;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 525, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/value-objects/RefreshToken.ts"],"sourcesContent":["/**\r\n * RefreshToken Value Object\r\n * \r\n * Encapsulates JWT refresh token logic.\r\n * Long-lived token for obtaining new access tokens (7 days).\r\n */\r\n\r\nimport jwt from 'jsonwebtoken';\r\nimport { randomBytes } from 'crypto';\r\n\r\nexport interface RefreshTokenPayload {\r\n  userId: string;\r\n  tokenId: string; // Unique ID for token rotation/revocation\r\n}\r\n\r\nexport class RefreshToken {\r\n  private readonly token: string;\r\n  private static readonly EXPIRY = '7d'; // 7 days\r\n  private static readonly SECRET = process.env.JWT_REFRESH_SECRET || 'default-refresh-secret-change-in-production';\r\n\r\n  private constructor(token: string) {\r\n    this.token = token;\r\n  }\r\n\r\n  /**\r\n   * Generate a new refresh token\r\n   */\r\n  public static generate(userId: string): RefreshToken {\r\n    const tokenId = RefreshToken.generateTokenId();\r\n\r\n    const token = jwt.sign(\r\n      { userId, tokenId } as RefreshTokenPayload,\r\n      RefreshToken.SECRET,\r\n      {\r\n        expiresIn: RefreshToken.EXPIRY,\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }\r\n    );\r\n\r\n    return new RefreshToken(token);\r\n  }\r\n\r\n  /**\r\n   * Verify and decode a refresh token\r\n   */\r\n  public static verify(token: string): RefreshTokenPayload {\r\n    try {\r\n      const decoded = jwt.verify(token, RefreshToken.SECRET, {\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }) as RefreshTokenPayload;\r\n\r\n      return decoded;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        throw new Error('Refresh token has expired');\r\n      }\r\n      if (error instanceof jwt.JsonWebTokenError) {\r\n        throw new Error('Invalid refresh token');\r\n      }\r\n      throw new Error('Refresh token verification failed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create from existing token string (for verification)\r\n   */\r\n  public static fromString(token: string): RefreshToken {\r\n    // Verify the token is valid before creating the value object\r\n    RefreshToken.verify(token);\r\n    return new RefreshToken(token);\r\n  }\r\n\r\n  /**\r\n   * Generate a unique token ID for tracking/revocation\r\n   */\r\n  private static generateTokenId(): string {\r\n    return randomBytes(16).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Get the token string\r\n   */\r\n  public getValue(): string {\r\n    return this.token;\r\n  }\r\n\r\n  /**\r\n   * Get the token ID from the token\r\n   */\r\n  public getTokenId(): string {\r\n    const payload = RefreshToken.verify(this.token);\r\n    return payload.tokenId;\r\n  }\r\n\r\n  /**\r\n   * Get the user ID from the token\r\n   */\r\n  public getUserId(): string {\r\n    const payload = RefreshToken.verify(this.token);\r\n    return payload.userId;\r\n  }\r\n\r\n  /**\r\n   * Check if token is expired\r\n   */\r\n  public isExpired(): boolean {\r\n    try {\r\n      jwt.verify(this.token, RefreshToken.SECRET);\r\n      return false;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;;;AAOO,MAAM;IACM,MAAc;IAC/B,OAAwB,SAAS,KAAK;IACtC,OAAwB,SAAS,QAAQ,GAAG,CAAC,kBAAkB,IAAI,8CAA8C;IAEjH,YAAoB,KAAa,CAAE;QACjC,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;GAEC,GACD,OAAc,SAAS,MAAc,EAAgB;QACnD,MAAM,UAAU,aAAa,eAAe;QAE5C,MAAM,QAAQ,2MAAG,CAAC,IAAI,CACpB;YAAE;YAAQ;QAAQ,GAClB,aAAa,MAAM,EACnB;YACE,WAAW,aAAa,MAAM;YAC9B,QAAQ;YACR,UAAU;QACZ;QAGF,OAAO,IAAI,aAAa;IAC1B;IAEA;;GAEC,GACD,OAAc,OAAO,KAAa,EAAuB;QACvD,IAAI;YACF,MAAM,UAAU,2MAAG,CAAC,MAAM,CAAC,OAAO,aAAa,MAAM,EAAE;gBACrD,QAAQ;gBACR,UAAU;YACZ;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;GAEC,GACD,OAAc,WAAW,KAAa,EAAgB;QACpD,6DAA6D;QAC7D,aAAa,MAAM,CAAC;QACpB,OAAO,IAAI,aAAa;IAC1B;IAEA;;GAEC,GACD,OAAe,kBAA0B;QACvC,OAAO,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;IAClC;IAEA;;GAEC,GACD,AAAO,WAAmB;QACxB,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA;;GAEC,GACD,AAAO,aAAqB;QAC1B,MAAM,UAAU,aAAa,MAAM,CAAC,IAAI,CAAC,KAAK;QAC9C,OAAO,QAAQ,OAAO;IACxB;IAEA;;GAEC,GACD,AAAO,YAAoB;QACzB,MAAM,UAAU,aAAa,MAAM,CAAC,IAAI,CAAC,KAAK;QAC9C,OAAO,QAAQ,MAAM;IACvB;IAEA;;GAEC,GACD,AAAO,YAAqB;QAC1B,IAAI;YACF,2MAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,aAAa,MAAM;YAC1C,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,OAAO;YACT;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 625, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/services/TokenService.ts"],"sourcesContent":["/**\r\n * TokenService\r\n * \r\n * Domain service for managing authentication tokens.\r\n * Handles token generation, verification, and refresh.\r\n */\r\n\r\nimport { AccessToken, AccessTokenPayload } from '../value-objects/AccessToken';\r\nimport { RefreshToken } from '../value-objects/RefreshToken';\r\n\r\nexport interface TokenPair {\r\n  accessToken: string;\r\n  refreshToken: string;\r\n}\r\n\r\nexport class TokenService {\r\n  /**\r\n   * Generate a new token pair (access + refresh)\r\n   */\r\n  public generateTokenPair(userId: string, email: string, role: string): TokenPair {\r\n    const accessTokenPayload: AccessTokenPayload = {\r\n      userId,\r\n      email,\r\n      role,\r\n    };\r\n\r\n    const accessToken = AccessToken.generate(accessTokenPayload);\r\n    const refreshToken = RefreshToken.generate(userId);\r\n\r\n    return {\r\n      accessToken: accessToken.getValue(),\r\n      refreshToken: refreshToken.getValue(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify an access token\r\n   */\r\n  public verifyAccessToken(token: string): AccessTokenPayload {\r\n    return AccessToken.verify(token);\r\n  }\r\n\r\n  /**\r\n   * Verify a refresh token\r\n   */\r\n  public verifyRefreshToken(token: string): { userId: string; tokenId: string } {\r\n    return RefreshToken.verify(token);\r\n  }\r\n\r\n  /**\r\n   * Refresh tokens - generate new pair from valid refresh token\r\n   */\r\n  public refreshTokens(\r\n    refreshTokenString: string,\r\n    email: string,\r\n    role: string\r\n  ): TokenPair {\r\n    // Verify the refresh token\r\n    const refreshToken = RefreshToken.fromString(refreshTokenString);\r\n    const userId = refreshToken.getUserId();\r\n\r\n    // Generate new token pair\r\n    return this.generateTokenPair(userId, email, role);\r\n  }\r\n\r\n  /**\r\n   * Extract token from Authorization header\r\n   */\r\n  public extractTokenFromHeader(authHeader: string | null): string | null {\r\n    if (!authHeader) {\r\n      return null;\r\n    }\r\n\r\n    // Expected format: \"Bearer <token>\"\r\n    const parts = authHeader.split(' ');\r\n\r\n    if (parts.length !== 2 || parts[0] !== 'Bearer') {\r\n      return null;\r\n    }\r\n\r\n    return parts[1];\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;;;AAOO,MAAM;IACX;;GAEC,GACD,AAAO,kBAAkB,MAAc,EAAE,KAAa,EAAE,IAAY,EAAa;QAC/E,MAAM,qBAAyC;YAC7C;YACA;YACA;QACF;QAEA,MAAM,cAAc,iMAAW,CAAC,QAAQ,CAAC;QACzC,MAAM,eAAe,mMAAY,CAAC,QAAQ,CAAC;QAE3C,OAAO;YACL,aAAa,YAAY,QAAQ;YACjC,cAAc,aAAa,QAAQ;QACrC;IACF;IAEA;;GAEC,GACD,AAAO,kBAAkB,KAAa,EAAsB;QAC1D,OAAO,iMAAW,CAAC,MAAM,CAAC;IAC5B;IAEA;;GAEC,GACD,AAAO,mBAAmB,KAAa,EAAuC;QAC5E,OAAO,mMAAY,CAAC,MAAM,CAAC;IAC7B;IAEA;;GAEC,GACD,AAAO,cACL,kBAA0B,EAC1B,KAAa,EACb,IAAY,EACD;QACX,2BAA2B;QAC3B,MAAM,eAAe,mMAAY,CAAC,UAAU,CAAC;QAC7C,MAAM,SAAS,aAAa,SAAS;QAErC,0BAA0B;QAC1B,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,OAAO;IAC/C;IAEA;;GAEC,GACD,AAAO,uBAAuB,UAAyB,EAAiB;QACtE,IAAI,CAAC,YAAY;YACf,OAAO;QACT;QAEA,oCAAoC;QACpC,MAAM,QAAQ,WAAW,KAAK,CAAC;QAE/B,IAAI,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,UAAU;YAC/C,OAAO;QACT;QAEA,OAAO,KAAK,CAAC,EAAE;IACjB;AACF"}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/apps/web/app/api/v1/auth/login/route.ts"],"sourcesContent":["/**\r\n * Login API Route\r\n * \r\n * POST /api/v1/auth/login\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { z } from 'zod';\r\nimport { prisma } from '@repo/database';\r\nimport { LoginUserUseCase } from '@repo/core/identity/application/use-cases/LoginUserUseCase';\r\nimport { PrismaUserRepository } from '@repo/core/identity/infrastructure/repositories/PrismaUserRepository';\r\nimport { TokenService } from '@repo/core/identity/domain/services/TokenService';\r\n\r\nconst LoginSchema = z.object({\r\n  email: z.string().email('Invalid email format'),\r\n  password: z.string().min(1, 'Password is required'),\r\n});\r\n\r\n// Handle CORS preflight\r\nexport async function OPTIONS() {\r\n  return new NextResponse(null, { status: 200 });\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    // 1. Parse and validate request body\r\n    const body = await request.json();\r\n    const validatedData = LoginSchema.parse(body);\r\n\r\n    // 2. Initialize dependencies\r\n    const userRepository = new PrismaUserRepository(prisma);\r\n    const tokenService = new TokenService();\r\n    const useCase = new LoginUserUseCase(userRepository, tokenService);\r\n\r\n    // 3. Execute use case\r\n    const result = await useCase.execute(validatedData);\r\n\r\n    // 4. Return success response\r\n    return NextResponse.json(\r\n      {\r\n        success: true,\r\n        data: result,\r\n        message: 'Login successful',\r\n      },\r\n      { status: 200 }\r\n    );\r\n  } catch (error) {\r\n    // Handle validation errors\r\n    if (error instanceof z.ZodError) {\r\n      return NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: 'Validation failed',\r\n          details: error.errors,\r\n        },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Handle business logic errors\r\n    if (error instanceof Error) {\r\n      // Don't reveal whether email or password was wrong (security)\r\n      if (error.message.includes('Invalid email or password')) {\r\n        return NextResponse.json(\r\n          {\r\n            success: false,\r\n            error: 'Invalid email or password',\r\n          },\r\n          { status: 401 } // Unauthorized\r\n        );\r\n      }\r\n\r\n      return NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error.message,\r\n        },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Unknown error\r\n    console.error('Login error:', error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: 'Internal server error',\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;AAED;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,cAAc,2NAAC,CAAC,MAAM,CAAC;IAC3B,OAAO,2NAAC,CAAC,MAAM,GAAG,KAAK,CAAC;IACxB,UAAU,2NAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;AAC9B;AAGO,eAAe;IACpB,OAAO,IAAI,+QAAY,CAAC,MAAM;QAAE,QAAQ;IAAI;AAC9C;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,qCAAqC;QACrC,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,gBAAgB,YAAY,KAAK,CAAC;QAExC,6BAA6B;QAC7B,MAAM,iBAAiB,IAAI,uNAAoB,CAAC,gKAAM;QACtD,MAAM,eAAe,IAAI,2LAAY;QACrC,MAAM,UAAU,IAAI,4MAAgB,CAAC,gBAAgB;QAErD,sBAAsB;QACtB,MAAM,SAAS,MAAM,QAAQ,OAAO,CAAC;QAErC,6BAA6B;QAC7B,OAAO,+QAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,MAAM;YACN,SAAS;QACX,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,2BAA2B;QAC3B,IAAI,iBAAiB,2NAAC,CAAC,QAAQ,EAAE;YAC/B,OAAO,+QAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO;gBACP,SAAS,MAAM,MAAM;YACvB,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,+BAA+B;QAC/B,IAAI,iBAAiB,OAAO;YAC1B,8DAA8D;YAC9D,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,8BAA8B;gBACvD,OAAO,+QAAY,CAAC,IAAI,CACtB;oBACE,SAAS;oBACT,OAAO;gBACT,GACA;oBAAE,QAAQ;gBAAI,EAAE,eAAe;;YAEnC;YAEA,OAAO,+QAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO,MAAM,OAAO;YACtB,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,gBAAgB;QAChB,QAAQ,KAAK,CAAC,gBAAgB;QAC9B,OAAO,+QAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;QACT,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}