{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/database/src/index.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\nexport * from '@prisma/client';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n    globalForPrisma.prisma ||\r\n    new PrismaClient({\r\n        log: ['query', 'error', 'warn'],\r\n    });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;;AAIA,MAAM;AAEC,MAAM,SACT,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACb,KAAK;QAAC;QAAS;QAAS;KAAO;AACnC;AAEJ,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/value-objects/AccessToken.ts"],"sourcesContent":["/**\r\n * AccessToken Value Object\r\n * \r\n * Encapsulates JWT access token logic.\r\n * Short-lived token for API authentication (15 minutes).\r\n */\r\n\r\nimport jwt from 'jsonwebtoken';\r\n\r\nexport interface AccessTokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n}\r\n\r\nexport class AccessToken {\r\n  private readonly token: string;\r\n  private static readonly EXPIRY = '15m'; // 15 minutes\r\n  private static readonly SECRET = process.env.JWT_ACCESS_SECRET || 'default-access-secret-change-in-production';\r\n\r\n  private constructor(token: string) {\r\n    this.token = token;\r\n  }\r\n\r\n  /**\r\n   * Generate a new access token\r\n   */\r\n  public static generate(payload: AccessTokenPayload): AccessToken {\r\n    const token = jwt.sign(\r\n      payload,\r\n      AccessToken.SECRET,\r\n      {\r\n        expiresIn: AccessToken.EXPIRY,\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }\r\n    );\r\n\r\n    return new AccessToken(token);\r\n  }\r\n\r\n  /**\r\n   * Verify and decode an access token\r\n   */\r\n  public static verify(token: string): AccessTokenPayload {\r\n    try {\r\n      const decoded = jwt.verify(token, AccessToken.SECRET, {\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }) as AccessTokenPayload;\r\n\r\n      return decoded;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        throw new Error('Access token has expired');\r\n      }\r\n      if (error instanceof jwt.JsonWebTokenError) {\r\n        throw new Error('Invalid access token');\r\n      }\r\n      throw new Error('Access token verification failed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create from existing token string (for verification)\r\n   */\r\n  public static fromString(token: string): AccessToken {\r\n    // Verify the token is valid before creating the value object\r\n    AccessToken.verify(token);\r\n    return new AccessToken(token);\r\n  }\r\n\r\n  /**\r\n   * Get the token string\r\n   */\r\n  public getValue(): string {\r\n    return this.token;\r\n  }\r\n\r\n  /**\r\n   * Check if token is expired\r\n   */\r\n  public isExpired(): boolean {\r\n    try {\r\n      jwt.verify(this.token, AccessToken.SECRET);\r\n      return false;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;;AAQO,MAAM;IACM,MAAc;IAC/B,OAAwB,SAAS,MAAM;IACvC,OAAwB,SAAS,QAAQ,GAAG,CAAC,iBAAiB,IAAI,6CAA6C;IAE/G,YAAoB,KAAa,CAAE;QACjC,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;GAEC,GACD,OAAc,SAAS,OAA2B,EAAe;QAC/D,MAAM,QAAQ,2MAAG,CAAC,IAAI,CACpB,SACA,YAAY,MAAM,EAClB;YACE,WAAW,YAAY,MAAM;YAC7B,QAAQ;YACR,UAAU;QACZ;QAGF,OAAO,IAAI,YAAY;IACzB;IAEA;;GAEC,GACD,OAAc,OAAO,KAAa,EAAsB;QACtD,IAAI;YACF,MAAM,UAAU,2MAAG,CAAC,MAAM,CAAC,OAAO,YAAY,MAAM,EAAE;gBACpD,QAAQ;gBACR,UAAU;YACZ;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;GAEC,GACD,OAAc,WAAW,KAAa,EAAe;QACnD,6DAA6D;QAC7D,YAAY,MAAM,CAAC;QACnB,OAAO,IAAI,YAAY;IACzB;IAEA;;GAEC,GACD,AAAO,WAAmB;QACxB,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA;;GAEC,GACD,AAAO,YAAqB;QAC1B,IAAI;YACF,2MAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,YAAY,MAAM;YACzC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,OAAO;YACT;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/value-objects/RefreshToken.ts"],"sourcesContent":["/**\r\n * RefreshToken Value Object\r\n * \r\n * Encapsulates JWT refresh token logic.\r\n * Long-lived token for obtaining new access tokens (7 days).\r\n */\r\n\r\nimport jwt from 'jsonwebtoken';\r\nimport { randomBytes } from 'crypto';\r\n\r\nexport interface RefreshTokenPayload {\r\n  userId: string;\r\n  tokenId: string; // Unique ID for token rotation/revocation\r\n}\r\n\r\nexport class RefreshToken {\r\n  private readonly token: string;\r\n  private static readonly EXPIRY = '7d'; // 7 days\r\n  private static readonly SECRET = process.env.JWT_REFRESH_SECRET || 'default-refresh-secret-change-in-production';\r\n\r\n  private constructor(token: string) {\r\n    this.token = token;\r\n  }\r\n\r\n  /**\r\n   * Generate a new refresh token\r\n   */\r\n  public static generate(userId: string): RefreshToken {\r\n    const tokenId = RefreshToken.generateTokenId();\r\n\r\n    const token = jwt.sign(\r\n      { userId, tokenId } as RefreshTokenPayload,\r\n      RefreshToken.SECRET,\r\n      {\r\n        expiresIn: RefreshToken.EXPIRY,\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }\r\n    );\r\n\r\n    return new RefreshToken(token);\r\n  }\r\n\r\n  /**\r\n   * Verify and decode a refresh token\r\n   */\r\n  public static verify(token: string): RefreshTokenPayload {\r\n    try {\r\n      const decoded = jwt.verify(token, RefreshToken.SECRET, {\r\n        issuer: 'treeverse-api',\r\n        audience: 'treeverse-client',\r\n      }) as RefreshTokenPayload;\r\n\r\n      return decoded;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        throw new Error('Refresh token has expired');\r\n      }\r\n      if (error instanceof jwt.JsonWebTokenError) {\r\n        throw new Error('Invalid refresh token');\r\n      }\r\n      throw new Error('Refresh token verification failed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create from existing token string (for verification)\r\n   */\r\n  public static fromString(token: string): RefreshToken {\r\n    // Verify the token is valid before creating the value object\r\n    RefreshToken.verify(token);\r\n    return new RefreshToken(token);\r\n  }\r\n\r\n  /**\r\n   * Generate a unique token ID for tracking/revocation\r\n   */\r\n  private static generateTokenId(): string {\r\n    return randomBytes(16).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Get the token string\r\n   */\r\n  public getValue(): string {\r\n    return this.token;\r\n  }\r\n\r\n  /**\r\n   * Get the token ID from the token\r\n   */\r\n  public getTokenId(): string {\r\n    const payload = RefreshToken.verify(this.token);\r\n    return payload.tokenId;\r\n  }\r\n\r\n  /**\r\n   * Get the user ID from the token\r\n   */\r\n  public getUserId(): string {\r\n    const payload = RefreshToken.verify(this.token);\r\n    return payload.userId;\r\n  }\r\n\r\n  /**\r\n   * Check if token is expired\r\n   */\r\n  public isExpired(): boolean {\r\n    try {\r\n      jwt.verify(this.token, RefreshToken.SECRET);\r\n      return false;\r\n    } catch (error) {\r\n      if (error instanceof jwt.TokenExpiredError) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;;;AAOO,MAAM;IACM,MAAc;IAC/B,OAAwB,SAAS,KAAK;IACtC,OAAwB,SAAS,QAAQ,GAAG,CAAC,kBAAkB,IAAI,8CAA8C;IAEjH,YAAoB,KAAa,CAAE;QACjC,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;GAEC,GACD,OAAc,SAAS,MAAc,EAAgB;QACnD,MAAM,UAAU,aAAa,eAAe;QAE5C,MAAM,QAAQ,2MAAG,CAAC,IAAI,CACpB;YAAE;YAAQ;QAAQ,GAClB,aAAa,MAAM,EACnB;YACE,WAAW,aAAa,MAAM;YAC9B,QAAQ;YACR,UAAU;QACZ;QAGF,OAAO,IAAI,aAAa;IAC1B;IAEA;;GAEC,GACD,OAAc,OAAO,KAAa,EAAuB;QACvD,IAAI;YACF,MAAM,UAAU,2MAAG,CAAC,MAAM,CAAC,OAAO,aAAa,MAAM,EAAE;gBACrD,QAAQ;gBACR,UAAU;YACZ;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;GAEC,GACD,OAAc,WAAW,KAAa,EAAgB;QACpD,6DAA6D;QAC7D,aAAa,MAAM,CAAC;QACpB,OAAO,IAAI,aAAa;IAC1B;IAEA;;GAEC,GACD,OAAe,kBAA0B;QACvC,OAAO,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;IAClC;IAEA;;GAEC,GACD,AAAO,WAAmB;QACxB,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA;;GAEC,GACD,AAAO,aAAqB;QAC1B,MAAM,UAAU,aAAa,MAAM,CAAC,IAAI,CAAC,KAAK;QAC9C,OAAO,QAAQ,OAAO;IACxB;IAEA;;GAEC,GACD,AAAO,YAAoB;QACzB,MAAM,UAAU,aAAa,MAAM,CAAC,IAAI,CAAC,KAAK;QAC9C,OAAO,QAAQ,MAAM;IACvB;IAEA;;GAEC,GACD,AAAO,YAAqB;QAC1B,IAAI;YACF,2MAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,aAAa,MAAM;YAC1C,OAAO;QACT,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,2MAAG,CAAC,iBAAiB,EAAE;gBAC1C,OAAO;YACT;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/packages/core/src/identity/domain/services/TokenService.ts"],"sourcesContent":["/**\r\n * TokenService\r\n * \r\n * Domain service for managing authentication tokens.\r\n * Handles token generation, verification, and refresh.\r\n */\r\n\r\nimport { AccessToken, AccessTokenPayload } from '../value-objects/AccessToken';\r\nimport { RefreshToken } from '../value-objects/RefreshToken';\r\n\r\nexport interface TokenPair {\r\n  accessToken: string;\r\n  refreshToken: string;\r\n}\r\n\r\nexport class TokenService {\r\n  /**\r\n   * Generate a new token pair (access + refresh)\r\n   */\r\n  public generateTokenPair(userId: string, email: string, role: string): TokenPair {\r\n    const accessTokenPayload: AccessTokenPayload = {\r\n      userId,\r\n      email,\r\n      role,\r\n    };\r\n\r\n    const accessToken = AccessToken.generate(accessTokenPayload);\r\n    const refreshToken = RefreshToken.generate(userId);\r\n\r\n    return {\r\n      accessToken: accessToken.getValue(),\r\n      refreshToken: refreshToken.getValue(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify an access token\r\n   */\r\n  public verifyAccessToken(token: string): AccessTokenPayload {\r\n    return AccessToken.verify(token);\r\n  }\r\n\r\n  /**\r\n   * Verify a refresh token\r\n   */\r\n  public verifyRefreshToken(token: string): { userId: string; tokenId: string } {\r\n    return RefreshToken.verify(token);\r\n  }\r\n\r\n  /**\r\n   * Refresh tokens - generate new pair from valid refresh token\r\n   */\r\n  public refreshTokens(\r\n    refreshTokenString: string,\r\n    email: string,\r\n    role: string\r\n  ): TokenPair {\r\n    // Verify the refresh token\r\n    const refreshToken = RefreshToken.fromString(refreshTokenString);\r\n    const userId = refreshToken.getUserId();\r\n\r\n    // Generate new token pair\r\n    return this.generateTokenPair(userId, email, role);\r\n  }\r\n\r\n  /**\r\n   * Extract token from Authorization header\r\n   */\r\n  public extractTokenFromHeader(authHeader: string | null): string | null {\r\n    if (!authHeader) {\r\n      return null;\r\n    }\r\n\r\n    // Expected format: \"Bearer <token>\"\r\n    const parts = authHeader.split(' ');\r\n\r\n    if (parts.length !== 2 || parts[0] !== 'Bearer') {\r\n      return null;\r\n    }\r\n\r\n    return parts[1];\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;;;AAOO,MAAM;IACX;;GAEC,GACD,AAAO,kBAAkB,MAAc,EAAE,KAAa,EAAE,IAAY,EAAa;QAC/E,MAAM,qBAAyC;YAC7C;YACA;YACA;QACF;QAEA,MAAM,cAAc,iMAAW,CAAC,QAAQ,CAAC;QACzC,MAAM,eAAe,mMAAY,CAAC,QAAQ,CAAC;QAE3C,OAAO;YACL,aAAa,YAAY,QAAQ;YACjC,cAAc,aAAa,QAAQ;QACrC;IACF;IAEA;;GAEC,GACD,AAAO,kBAAkB,KAAa,EAAsB;QAC1D,OAAO,iMAAW,CAAC,MAAM,CAAC;IAC5B;IAEA;;GAEC,GACD,AAAO,mBAAmB,KAAa,EAAuC;QAC5E,OAAO,mMAAY,CAAC,MAAM,CAAC;IAC7B;IAEA;;GAEC,GACD,AAAO,cACL,kBAA0B,EAC1B,KAAa,EACb,IAAY,EACD;QACX,2BAA2B;QAC3B,MAAM,eAAe,mMAAY,CAAC,UAAU,CAAC;QAC7C,MAAM,SAAS,aAAa,SAAS;QAErC,0BAA0B;QAC1B,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,OAAO;IAC/C;IAEA;;GAEC,GACD,AAAO,uBAAuB,UAAyB,EAAiB;QACtE,IAAI,CAAC,YAAY;YACf,OAAO;QACT;QAEA,oCAAoC;QACpC,MAAM,QAAQ,WAAW,KAAK,CAAC;QAE/B,IAAI,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,UAAU;YAC/C,OAAO;QACT;QAEA,OAAO,KAAK,CAAC,EAAE;IACjB;AACF"}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/apps/web/lib/middleware/auth.ts"],"sourcesContent":["/**\r\n * Authentication Middleware\r\n * \r\n * Verifies JWT tokens and attaches user information to requests.\r\n */\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { TokenService } from '@repo/core/identity/domain/services/TokenService';\r\n\r\nexport interface AuthenticatedRequest extends NextRequest {\r\n  user?: {\r\n    userId: string;\r\n    email: string;\r\n    role: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Extract and verify JWT token from request\r\n */\r\nexport async function authenticateRequest(\r\n  request: NextRequest\r\n): Promise<{ userId: string; email: string; role: string }> {\r\n  const tokenService = new TokenService();\r\n\r\n  // Extract token from Authorization header\r\n  const authHeader = request.headers.get('Authorization');\r\n  const token = tokenService.extractTokenFromHeader(authHeader);\r\n\r\n  if (!token) {\r\n    throw new Error('No authentication token provided');\r\n  }\r\n\r\n  // Verify token\r\n  try {\r\n    const payload = tokenService.verifyAccessToken(token);\r\n\r\n    return {\r\n      userId: payload.userId,\r\n      email: payload.email,\r\n      role: payload.role,\r\n    };\r\n  } catch (error) {\r\n    if (error instanceof Error) {\r\n      throw new Error(`Authentication failed: ${error.message}`);\r\n    }\r\n    throw new Error('Authentication failed');\r\n  }\r\n}\r\n\r\n/**\r\n * Middleware to require specific roles\r\n */\r\nexport function requireRole(allowedRoles: string[]) {\r\n  return async (request: AuthenticatedRequest) => {\r\n    const user = await authenticateRequest(request);\r\n\r\n    if (!allowedRoles.includes(user.role)) {\r\n      throw new Error(\r\n        `Forbidden: Requires one of the following roles: ${allowedRoles.join(', ')}`\r\n      );\r\n    }\r\n\r\n    return user;\r\n  };\r\n}\r\n\r\n/**\r\n * Common role checks\r\n */\r\nexport const requireAdmin = requireRole(['ADMIN']);\r\nexport const requireSeller = requireRole(['SELLER', 'ADMIN']);\r\nexport const requireAuthenticated = authenticateRequest;\r\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;;;;;AAGD;;AAaO,eAAe,oBACpB,OAAoB;IAEpB,MAAM,eAAe,IAAI,2LAAY;IAErC,0CAA0C;IAC1C,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,QAAQ,aAAa,sBAAsB,CAAC;IAElD,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,eAAe;IACf,IAAI;QACF,MAAM,UAAU,aAAa,iBAAiB,CAAC;QAE/C,OAAO;YACL,QAAQ,QAAQ,MAAM;YACtB,OAAO,QAAQ,KAAK;YACpB,MAAM,QAAQ,IAAI;QACpB;IACF,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,OAAO;YAC1B,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,MAAM,OAAO,EAAE;QAC3D;QACA,MAAM,IAAI,MAAM;IAClB;AACF;AAKO,SAAS,YAAY,YAAsB;IAChD,OAAO,OAAO;QACZ,MAAM,OAAO,MAAM,oBAAoB;QAEvC,IAAI,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;YACrC,MAAM,IAAI,MACR,CAAC,gDAAgD,EAAE,aAAa,IAAI,CAAC,OAAO;QAEhF;QAEA,OAAO;IACT;AACF;AAKO,MAAM,eAAe,YAAY;IAAC;CAAQ;AAC1C,MAAM,gBAAgB,YAAY;IAAC;IAAU;CAAQ;AACrD,MAAM,uBAAuB"}},
    {"offset": {"line": 401, "column": 0}, "map": {"version":3,"sources":["file:///J:/projects/tree/apps/web/app/api/v1/listings/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { z } from 'zod';\r\nimport { prisma } from '@repo/database'; \r\nimport { CreateListingUseCase } from '@repo/core/marketplace/application/use-cases/CreateListingUseCase.js';\r\nimport { SearchListingsUseCase } from '@repo/core/marketplace/application/use-cases/SearchListingsUseCase.js';\r\nimport { PrismaListingRepository } from '@repo/core/marketplace/infrastructure/repositories/PrismaListingRepository.js';\r\nimport { PrismaSellerRepository } from '@repo/core/marketplace/infrastructure/repositories/PrismaSellerRepository.js';\r\nimport { requireSeller } from '@/lib/middleware/auth';\r\n\r\n// Validation Schemas\r\nconst CreateListingSchema = z.object({\r\n  speciesId: z.string().uuid('Invalid species ID format'),\r\n  title: z.string().min(10, 'Title must be at least 10 characters').max(200, 'Title cannot exceed 200 characters'),\r\n  description: z.string().min(50, 'Description must be at least 50 characters'),\r\n  basePrice: z.number().positive('Price must be positive'),\r\n  inventory: z.number().int().min(0, 'Inventory cannot be negative'),\r\n  metadata: z.object({}).optional(),\r\n});\r\n\r\nconst SearchListingsSchema = z.object({\r\n  speciesId: z.string().uuid().optional(),\r\n  sellerId: z.string().uuid().optional(),\r\n  status: z.enum(['DRAFT', 'ACTIVE', 'SOLD_OUT', 'FLAGGED', 'ARCHIVED']).optional(),\r\n  minPrice: z.number().positive().optional(),\r\n  maxPrice: z.number().positive().optional(),\r\n  searchTerm: z.string().optional(),\r\n  page: z.number().int().positive().optional(),\r\n  pageSize: z.number().int().positive().max(100).optional(),\r\n});\r\n\r\n/**\r\n * POST /api/v1/listings\r\n * Create a new listing (PROTECTED - Requires SELLER role)\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    // 1. Authenticate and check role\r\n    const authenticatedUser = await requireSeller(request);\r\n\r\n    // 2. Parse and validate request body\r\n    const body = await request.json();\r\n    const validatedData = CreateListingSchema.parse(body);\r\n\r\n    // 3. Initialize repositories and use case\r\n    const listingRepository = new PrismaListingRepository(prisma);\r\n    const sellerRepository = new PrismaSellerRepository(prisma);\r\n    const useCase = new CreateListingUseCase(listingRepository, sellerRepository);\r\n\r\n    // 4. Execute use case with authenticated user's ID\r\n    const result = await useCase.execute({\r\n      ...validatedData,\r\n      sellerId: authenticatedUser.userId, // Use authenticated user's ID, not from request body\r\n    });\r\n\r\n    // 5. Return success response\r\n    return NextResponse.json(\r\n      {\r\n        success: true,\r\n        data: result,\r\n        message: 'Listing created successfully',\r\n      },\r\n      { status: 201 }\r\n    );\r\n  } catch (error) {\r\n    // Handle authentication errors\r\n    if (error instanceof Error && error.message.includes('Authentication')) {\r\n      return NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error.message,\r\n        },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\n/**\r\n * GET /api/v1/listings\r\n * Search listings with filters\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // 1. Parse query parameters\r\n    const searchParams = request.nextUrl.searchParams;\r\n\r\n    const queryData = {\r\n      speciesId: searchParams.get('speciesId') || undefined,\r\n      sellerId: searchParams.get('sellerId') || undefined,\r\n      status: searchParams.get('status')?.toUpperCase() || undefined,\r\n      minPrice: searchParams.get('minPrice') ? parseFloat(searchParams.get('minPrice')!) : undefined,\r\n      maxPrice: searchParams.get('maxPrice') ? parseFloat(searchParams.get('maxPrice')!) : undefined,\r\n      searchTerm: searchParams.get('searchTerm') || undefined,\r\n      page: searchParams.get('page') ? parseInt(searchParams.get('page')!) : undefined,\r\n      pageSize: searchParams.get('pageSize') ? parseInt(searchParams.get('pageSize')!) : undefined,\r\n    };\r\n\r\n    // 2. Validate query parameters\r\n    const validatedData = SearchListingsSchema.parse(queryData);\r\n\r\n    // 3. Initialize repository and use case\r\n    const listingRepository = new PrismaListingRepository(prisma);\r\n    const useCase = new SearchListingsUseCase(listingRepository);\r\n\r\n    // 4. Execute use case\r\n    const result = await useCase.execute(validatedData);\r\n\r\n    // 5. Return success response\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: result,\r\n    });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\n/**\r\n * Centralized error handler\r\n */\r\nfunction handleError(error: unknown): NextResponse {\r\n  // Validation errors (Zod)\r\n  if (error instanceof z.ZodError) {\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: 'Validation failed',\r\n        details: error.errors.map(err => ({\r\n          field: err.path.join('.'),\r\n          message: err.message,\r\n        })),\r\n      },\r\n      { status: 400 }\r\n    );\r\n  }\r\n\r\n  // Business logic errors\r\n  if (error instanceof Error) {\r\n    // Check for specific error messages\r\n    if (error.message.includes('not found')) {\r\n      return NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error.message,\r\n        },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    if (error.message.includes('Only verified sellers')) {\r\n      return NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error.message,\r\n        },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    // Generic business error\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: error.message,\r\n      },\r\n      { status: 400 }\r\n    );\r\n  }\r\n\r\n  // Unknown error\r\n  console.error('Unexpected error:', error);\r\n  return NextResponse.json(\r\n    {\r\n      success: false,\r\n      error: 'Internal server error',\r\n    },\r\n    { status: 500 }\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;AAEA,qBAAqB;AACrB,MAAM,sBAAsB,2NAAC,CAAC,MAAM,CAAC;IACnC,WAAW,2NAAC,CAAC,MAAM,GAAG,IAAI,CAAC;IAC3B,OAAO,2NAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,wCAAwC,GAAG,CAAC,KAAK;IAC3E,aAAa,2NAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI;IAChC,WAAW,2NAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,WAAW,2NAAC,CAAC,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG;IACnC,UAAU,2NAAC,CAAC,MAAM,CAAC,CAAC,GAAG,QAAQ;AACjC;AAEA,MAAM,uBAAuB,2NAAC,CAAC,MAAM,CAAC;IACpC,WAAW,2NAAC,CAAC,MAAM,GAAG,IAAI,GAAG,QAAQ;IACrC,UAAU,2NAAC,CAAC,MAAM,GAAG,IAAI,GAAG,QAAQ;IACpC,QAAQ,2NAAC,CAAC,IAAI,CAAC;QAAC;QAAS;QAAU;QAAY;QAAW;KAAW,EAAE,QAAQ;IAC/E,UAAU,2NAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ;IACxC,UAAU,2NAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ;IACxC,YAAY,2NAAC,CAAC,MAAM,GAAG,QAAQ;IAC/B,MAAM,2NAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,QAAQ;IAC1C,UAAU,2NAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,CAAC,KAAK,QAAQ;AACzD;AAMO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,iCAAiC;QACjC,MAAM,oBAAoB,MAAM,IAAA,2JAAa,EAAC;QAE9C,qCAAqC;QACrC,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,gBAAgB,oBAAoB,KAAK,CAAC;QAEhD,0CAA0C;QAC1C,MAAM,oBAAoB,IAAI,wBAAwB,gKAAM;QAC5D,MAAM,mBAAmB,IAAI,uBAAuB,gKAAM;QAC1D,MAAM,UAAU,IAAI,qBAAqB,mBAAmB;QAE5D,mDAAmD;QACnD,MAAM,SAAS,MAAM,QAAQ,OAAO,CAAC;YACnC,GAAG,aAAa;YAChB,UAAU,kBAAkB,MAAM;QACpC;QAEA,6BAA6B;QAC7B,OAAO,+QAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,MAAM;YACN,SAAS;QACX,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,+BAA+B;QAC/B,IAAI,iBAAiB,SAAS,MAAM,OAAO,CAAC,QAAQ,CAAC,mBAAmB;YACtE,OAAO,+QAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO,MAAM,OAAO;YACtB,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,YAAY;IACrB;AACF;AAMO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,4BAA4B;QAC5B,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QAEjD,MAAM,YAAY;YAChB,WAAW,aAAa,GAAG,CAAC,gBAAgB;YAC5C,UAAU,aAAa,GAAG,CAAC,eAAe;YAC1C,QAAQ,aAAa,GAAG,CAAC,WAAW,iBAAiB;YACrD,UAAU,aAAa,GAAG,CAAC,cAAc,WAAW,aAAa,GAAG,CAAC,eAAgB;YACrF,UAAU,aAAa,GAAG,CAAC,cAAc,WAAW,aAAa,GAAG,CAAC,eAAgB;YACrF,YAAY,aAAa,GAAG,CAAC,iBAAiB;YAC9C,MAAM,aAAa,GAAG,CAAC,UAAU,SAAS,aAAa,GAAG,CAAC,WAAY;YACvE,UAAU,aAAa,GAAG,CAAC,cAAc,SAAS,aAAa,GAAG,CAAC,eAAgB;QACrF;QAEA,+BAA+B;QAC/B,MAAM,gBAAgB,qBAAqB,KAAK,CAAC;QAEjD,wCAAwC;QACxC,MAAM,oBAAoB,IAAI,wBAAwB,gKAAM;QAC5D,MAAM,UAAU,IAAI,sBAAsB;QAE1C,sBAAsB;QACtB,MAAM,SAAS,MAAM,QAAQ,OAAO,CAAC;QAErC,6BAA6B;QAC7B,OAAO,+QAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,OAAO,YAAY;IACrB;AACF;AAEA;;CAEC,GACD,SAAS,YAAY,KAAc;IACjC,0BAA0B;IAC1B,IAAI,iBAAiB,2NAAC,CAAC,QAAQ,EAAE;QAC/B,OAAO,+QAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;YACP,SAAS,MAAM,MAAM,CAAC,GAAG,CAAC,CAAA,MAAO,CAAC;oBAChC,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC;oBACrB,SAAS,IAAI,OAAO;gBACtB,CAAC;QACH,GACA;YAAE,QAAQ;QAAI;IAElB;IAEA,wBAAwB;IACxB,IAAI,iBAAiB,OAAO;QAC1B,oCAAoC;QACpC,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,cAAc;YACvC,OAAO,+QAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO,MAAM,OAAO;YACtB,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,0BAA0B;YACnD,OAAO,+QAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO,MAAM,OAAO;YACtB,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,OAAO,+QAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO,MAAM,OAAO;QACtB,GACA;YAAE,QAAQ;QAAI;IAElB;IAEA,gBAAgB;IAChB,QAAQ,KAAK,CAAC,qBAAqB;IACnC,OAAO,+QAAY,CAAC,IAAI,CACtB;QACE,SAAS;QACT,OAAO;IACT,GACA;QAAE,QAAQ;IAAI;AAElB"}}]
}